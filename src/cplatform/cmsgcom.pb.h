// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cmsgcom.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cmsgcom_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cmsgcom_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cmsgtype.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cmsgcom_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cmsgcom_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cmsgcom_2eproto;
namespace cmsg {
class CAddLogReq;
class CAddLogReqDefaultTypeInternal;
extern CAddLogReqDefaultTypeInternal _CAddLogReq_default_instance_;
class CAddUserReq;
class CAddUserReqDefaultTypeInternal;
extern CAddUserReqDefaultTypeInternal _CAddUserReq_default_instance_;
class CConfig;
class CConfigDefaultTypeInternal;
extern CConfigDefaultTypeInternal _CConfig_default_instance_;
class CConfigList;
class CConfigListDefaultTypeInternal;
extern CConfigListDefaultTypeInternal _CConfigList_default_instance_;
class CDirConfig;
class CDirConfigDefaultTypeInternal;
extern CDirConfigDefaultTypeInternal _CDirConfig_default_instance_;
class CDirReq;
class CDirReqDefaultTypeInternal;
extern CDirReqDefaultTypeInternal _CDirReq_default_instance_;
class CDirRes;
class CDirResDefaultTypeInternal;
extern CDirResDefaultTypeInternal _CDirRes_default_instance_;
class CDirRes_CDir;
class CDirRes_CDirDefaultTypeInternal;
extern CDirRes_CDirDefaultTypeInternal _CDirRes_CDir_default_instance_;
class CDownloadAllConfigReq;
class CDownloadAllConfigReqDefaultTypeInternal;
extern CDownloadAllConfigReqDefaultTypeInternal _CDownloadAllConfigReq_default_instance_;
class CDownloadconfigReq;
class CDownloadconfigReqDefaultTypeInternal;
extern CDownloadconfigReqDefaultTypeInternal _CDownloadconfigReq_default_instance_;
class CGatewayConfig;
class CGatewayConfigDefaultTypeInternal;
extern CGatewayConfigDefaultTypeInternal _CGatewayConfig_default_instance_;
class CGetServiceReq;
class CGetServiceReqDefaultTypeInternal;
extern CGetServiceReqDefaultTypeInternal _CGetServiceReq_default_instance_;
class CLoginReq;
class CLoginReqDefaultTypeInternal;
extern CLoginReqDefaultTypeInternal _CLoginReq_default_instance_;
class CLoginRes;
class CLoginResDefaultTypeInternal;
extern CLoginResDefaultTypeInternal _CLoginRes_default_instance_;
class CMessageRes;
class CMessageResDefaultTypeInternal;
extern CMessageResDefaultTypeInternal _CMessageRes_default_instance_;
class CMsgHead;
class CMsgHeadDefaultTypeInternal;
extern CMsgHeadDefaultTypeInternal _CMsgHead_default_instance_;
class CMsgHeart;
class CMsgHeartDefaultTypeInternal;
extern CMsgHeartDefaultTypeInternal _CMsgHeart_default_instance_;
class CRegisterReq;
class CRegisterReqDefaultTypeInternal;
extern CRegisterReqDefaultTypeInternal _CRegisterReq_default_instance_;
class CServiceMap;
class CServiceMapDefaultTypeInternal;
extern CServiceMapDefaultTypeInternal _CServiceMap_default_instance_;
class CServiceMap_CService;
class CServiceMap_CServiceDefaultTypeInternal;
extern CServiceMap_CServiceDefaultTypeInternal _CServiceMap_CService_default_instance_;
class CServiceMap_CServiceList;
class CServiceMap_CServiceListDefaultTypeInternal;
extern CServiceMap_CServiceListDefaultTypeInternal _CServiceMap_CServiceList_default_instance_;
class CServiceMap_ServiceMapEntry_DoNotUse;
class CServiceMap_ServiceMapEntry_DoNotUseDefaultTypeInternal;
extern CServiceMap_ServiceMapEntry_DoNotUseDefaultTypeInternal _CServiceMap_ServiceMapEntry_DoNotUse_default_instance_;
}  // namespace cmsg
PROTOBUF_NAMESPACE_OPEN
template<> ::cmsg::CAddLogReq* Arena::CreateMaybeMessage<::cmsg::CAddLogReq>(Arena*);
template<> ::cmsg::CAddUserReq* Arena::CreateMaybeMessage<::cmsg::CAddUserReq>(Arena*);
template<> ::cmsg::CConfig* Arena::CreateMaybeMessage<::cmsg::CConfig>(Arena*);
template<> ::cmsg::CConfigList* Arena::CreateMaybeMessage<::cmsg::CConfigList>(Arena*);
template<> ::cmsg::CDirConfig* Arena::CreateMaybeMessage<::cmsg::CDirConfig>(Arena*);
template<> ::cmsg::CDirReq* Arena::CreateMaybeMessage<::cmsg::CDirReq>(Arena*);
template<> ::cmsg::CDirRes* Arena::CreateMaybeMessage<::cmsg::CDirRes>(Arena*);
template<> ::cmsg::CDirRes_CDir* Arena::CreateMaybeMessage<::cmsg::CDirRes_CDir>(Arena*);
template<> ::cmsg::CDownloadAllConfigReq* Arena::CreateMaybeMessage<::cmsg::CDownloadAllConfigReq>(Arena*);
template<> ::cmsg::CDownloadconfigReq* Arena::CreateMaybeMessage<::cmsg::CDownloadconfigReq>(Arena*);
template<> ::cmsg::CGatewayConfig* Arena::CreateMaybeMessage<::cmsg::CGatewayConfig>(Arena*);
template<> ::cmsg::CGetServiceReq* Arena::CreateMaybeMessage<::cmsg::CGetServiceReq>(Arena*);
template<> ::cmsg::CLoginReq* Arena::CreateMaybeMessage<::cmsg::CLoginReq>(Arena*);
template<> ::cmsg::CLoginRes* Arena::CreateMaybeMessage<::cmsg::CLoginRes>(Arena*);
template<> ::cmsg::CMessageRes* Arena::CreateMaybeMessage<::cmsg::CMessageRes>(Arena*);
template<> ::cmsg::CMsgHead* Arena::CreateMaybeMessage<::cmsg::CMsgHead>(Arena*);
template<> ::cmsg::CMsgHeart* Arena::CreateMaybeMessage<::cmsg::CMsgHeart>(Arena*);
template<> ::cmsg::CRegisterReq* Arena::CreateMaybeMessage<::cmsg::CRegisterReq>(Arena*);
template<> ::cmsg::CServiceMap* Arena::CreateMaybeMessage<::cmsg::CServiceMap>(Arena*);
template<> ::cmsg::CServiceMap_CService* Arena::CreateMaybeMessage<::cmsg::CServiceMap_CService>(Arena*);
template<> ::cmsg::CServiceMap_CServiceList* Arena::CreateMaybeMessage<::cmsg::CServiceMap_CServiceList>(Arena*);
template<> ::cmsg::CServiceMap_ServiceMapEntry_DoNotUse* Arena::CreateMaybeMessage<::cmsg::CServiceMap_ServiceMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cmsg {

enum CLoginRes_CLoginResType : int {
  CLoginRes_CLoginResType_OK = 0,
  CLoginRes_CLoginResType_ERROR = 1,
  CLoginRes_CLoginResType_NOUSER = 2,
  CLoginRes_CLoginResType_CLoginRes_CLoginResType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CLoginRes_CLoginResType_CLoginRes_CLoginResType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CLoginRes_CLoginResType_IsValid(int value);
constexpr CLoginRes_CLoginResType CLoginRes_CLoginResType_CLoginResType_MIN = CLoginRes_CLoginResType_OK;
constexpr CLoginRes_CLoginResType CLoginRes_CLoginResType_CLoginResType_MAX = CLoginRes_CLoginResType_NOUSER;
constexpr int CLoginRes_CLoginResType_CLoginResType_ARRAYSIZE = CLoginRes_CLoginResType_CLoginResType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CLoginRes_CLoginResType_descriptor();
template<typename T>
inline const std::string& CLoginRes_CLoginResType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CLoginRes_CLoginResType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CLoginRes_CLoginResType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CLoginRes_CLoginResType_descriptor(), enum_t_value);
}
inline bool CLoginRes_CLoginResType_Parse(
    const std::string& name, CLoginRes_CLoginResType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CLoginRes_CLoginResType>(
    CLoginRes_CLoginResType_descriptor(), name, value);
}
enum CDirRes_CDirType : int {
  CDirRes_CDirType_OK = 0,
  CDirRes_CDirType_ERROR = 1,
  CDirRes_CDirType_NODIR = 2,
  CDirRes_CDirType_CDirRes_CDirType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CDirRes_CDirType_CDirRes_CDirType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CDirRes_CDirType_IsValid(int value);
constexpr CDirRes_CDirType CDirRes_CDirType_CDirType_MIN = CDirRes_CDirType_OK;
constexpr CDirRes_CDirType CDirRes_CDirType_CDirType_MAX = CDirRes_CDirType_NODIR;
constexpr int CDirRes_CDirType_CDirType_ARRAYSIZE = CDirRes_CDirType_CDirType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CDirRes_CDirType_descriptor();
template<typename T>
inline const std::string& CDirRes_CDirType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CDirRes_CDirType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CDirRes_CDirType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CDirRes_CDirType_descriptor(), enum_t_value);
}
inline bool CDirRes_CDirType_Parse(
    const std::string& name, CDirRes_CDirType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CDirRes_CDirType>(
    CDirRes_CDirType_descriptor(), name, value);
}
enum CMessageRes_CReturn : int {
  CMessageRes_CReturn_OK = 0,
  CMessageRes_CReturn_ERROR = 1,
  CMessageRes_CReturn_CMessageRes_CReturn_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CMessageRes_CReturn_CMessageRes_CReturn_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CMessageRes_CReturn_IsValid(int value);
constexpr CMessageRes_CReturn CMessageRes_CReturn_CReturn_MIN = CMessageRes_CReturn_OK;
constexpr CMessageRes_CReturn CMessageRes_CReturn_CReturn_MAX = CMessageRes_CReturn_ERROR;
constexpr int CMessageRes_CReturn_CReturn_ARRAYSIZE = CMessageRes_CReturn_CReturn_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMessageRes_CReturn_descriptor();
template<typename T>
inline const std::string& CMessageRes_CReturn_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMessageRes_CReturn>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMessageRes_CReturn_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMessageRes_CReturn_descriptor(), enum_t_value);
}
inline bool CMessageRes_CReturn_Parse(
    const std::string& name, CMessageRes_CReturn* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMessageRes_CReturn>(
    CMessageRes_CReturn_descriptor(), name, value);
}
enum CLogLevel : int {
  CLOG_DEBUG = 0,
  CLOG_INFO = 1,
  CLOG_ERROR = 2,
  CLOG_FATAL = 3,
  CLogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CLogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CLogLevel_IsValid(int value);
constexpr CLogLevel CLogLevel_MIN = CLOG_DEBUG;
constexpr CLogLevel CLogLevel_MAX = CLOG_FATAL;
constexpr int CLogLevel_ARRAYSIZE = CLogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CLogLevel_descriptor();
template<typename T>
inline const std::string& CLogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CLogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CLogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CLogLevel_descriptor(), enum_t_value);
}
inline bool CLogLevel_Parse(
    const std::string& name, CLogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CLogLevel>(
    CLogLevel_descriptor(), name, value);
}
enum CServiceType : int {
  ONE = 0,
  ALL = 1,
  CServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CServiceType_IsValid(int value);
constexpr CServiceType CServiceType_MIN = ONE;
constexpr CServiceType CServiceType_MAX = ALL;
constexpr int CServiceType_ARRAYSIZE = CServiceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CServiceType_descriptor();
template<typename T>
inline const std::string& CServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CServiceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CServiceType_descriptor(), enum_t_value);
}
inline bool CServiceType_Parse(
    const std::string& name, CServiceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CServiceType>(
    CServiceType_descriptor(), name, value);
}
// ===================================================================

class CMsgHead :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CMsgHead) */ {
 public:
  CMsgHead();
  virtual ~CMsgHead();

  CMsgHead(const CMsgHead& from);
  CMsgHead(CMsgHead&& from) noexcept
    : CMsgHead() {
    *this = ::std::move(from);
  }

  inline CMsgHead& operator=(const CMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgHead& operator=(CMsgHead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CMsgHead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgHead* internal_default_instance() {
    return reinterpret_cast<const CMsgHead*>(
               &_CMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgHead* other);
  friend void swap(CMsgHead& a, CMsgHead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgHead* New() const final {
    return CreateMaybeMessage<CMsgHead>(nullptr);
  }

  CMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsgHead>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMsgHead& from);
  void MergeFrom(const CMsgHead& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgHead* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CMsgHead";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // string service_name = 4;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 4;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // int32 msg_size = 1;
  void clear_msg_size();
  static const int kMsgSizeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 msg_size() const;
  void set_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .cmsg.CMsgType msg_type = 2;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 2;
  ::cmsg::CMsgType msg_type() const;
  void set_msg_type(::cmsg::CMsgType value);

  // int64 msg_id = 5;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int64 msg_id() const;
  void set_msg_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:cmsg.CMsgHead)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 msg_size_;
  int msg_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 msg_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CMsgHeart :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CMsgHeart) */ {
 public:
  CMsgHeart();
  virtual ~CMsgHeart();

  CMsgHeart(const CMsgHeart& from);
  CMsgHeart(CMsgHeart&& from) noexcept
    : CMsgHeart() {
    *this = ::std::move(from);
  }

  inline CMsgHeart& operator=(const CMsgHeart& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgHeart& operator=(CMsgHeart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CMsgHeart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgHeart* internal_default_instance() {
    return reinterpret_cast<const CMsgHeart*>(
               &_CMsgHeart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgHeart* other);
  friend void swap(CMsgHeart& a, CMsgHeart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgHeart* New() const final {
    return CreateMaybeMessage<CMsgHeart>(nullptr);
  }

  CMsgHeart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsgHeart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMsgHeart& from);
  void MergeFrom(const CMsgHeart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgHeart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CMsgHeart";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:cmsg.CMsgHeart)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CAddLogReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CAddLogReq) */ {
 public:
  CAddLogReq();
  virtual ~CAddLogReq();

  CAddLogReq(const CAddLogReq& from);
  CAddLogReq(CAddLogReq&& from) noexcept
    : CAddLogReq() {
    *this = ::std::move(from);
  }

  inline CAddLogReq& operator=(const CAddLogReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAddLogReq& operator=(CAddLogReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CAddLogReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAddLogReq* internal_default_instance() {
    return reinterpret_cast<const CAddLogReq*>(
               &_CAddLogReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CAddLogReq* other);
  friend void swap(CAddLogReq& a, CAddLogReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAddLogReq* New() const final {
    return CreateMaybeMessage<CAddLogReq>(nullptr);
  }

  CAddLogReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CAddLogReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CAddLogReq& from);
  void MergeFrom(const CAddLogReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAddLogReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CAddLogReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_ip = 1;
  void clear_service_ip();
  static const int kServiceIpFieldNumber = 1;
  const std::string& service_ip() const;
  void set_service_ip(const std::string& value);
  void set_service_ip(std::string&& value);
  void set_service_ip(const char* value);
  void set_service_ip(const char* value, size_t size);
  std::string* mutable_service_ip();
  std::string* release_service_ip();
  void set_allocated_service_ip(std::string* service_ip);

  // string service_name = 3;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 3;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // bytes log_txt = 4;
  void clear_log_txt();
  static const int kLogTxtFieldNumber = 4;
  const std::string& log_txt() const;
  void set_log_txt(const std::string& value);
  void set_log_txt(std::string&& value);
  void set_log_txt(const char* value);
  void set_log_txt(const void* value, size_t size);
  std::string* mutable_log_txt();
  std::string* release_log_txt();
  void set_allocated_log_txt(std::string* log_txt);

  // string filename = 7;
  void clear_filename();
  static const int kFilenameFieldNumber = 7;
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // int32 service_port = 2;
  void clear_service_port();
  static const int kServicePortFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port() const;
  void set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 log_time = 5;
  void clear_log_time();
  static const int kLogTimeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 log_time() const;
  void set_log_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .cmsg.CLogLevel log_level = 6;
  void clear_log_level();
  static const int kLogLevelFieldNumber = 6;
  ::cmsg::CLogLevel log_level() const;
  void set_log_level(::cmsg::CLogLevel value);

  // int32 line = 8;
  void clear_line();
  static const int kLineFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 line() const;
  void set_line(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CAddLogReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_txt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port_;
  ::PROTOBUF_NAMESPACE_ID::int32 log_time_;
  int log_level_;
  ::PROTOBUF_NAMESPACE_ID::int32 line_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CLoginReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CLoginReq) */ {
 public:
  CLoginReq();
  virtual ~CLoginReq();

  CLoginReq(const CLoginReq& from);
  CLoginReq(CLoginReq&& from) noexcept
    : CLoginReq() {
    *this = ::std::move(from);
  }

  inline CLoginReq& operator=(const CLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLoginReq& operator=(CLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CLoginReq* internal_default_instance() {
    return reinterpret_cast<const CLoginReq*>(
               &_CLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CLoginReq* other);
  friend void swap(CLoginReq& a, CLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CLoginReq* New() const final {
    return CreateMaybeMessage<CLoginReq>(nullptr);
  }

  CLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CLoginReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CLoginReq& from);
  void MergeFrom(const CLoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CLoginReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // @@protoc_insertion_point(class_scope:cmsg.CLoginReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CLoginRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CLoginRes) */ {
 public:
  CLoginRes();
  virtual ~CLoginRes();

  CLoginRes(const CLoginRes& from);
  CLoginRes(CLoginRes&& from) noexcept
    : CLoginRes() {
    *this = ::std::move(from);
  }

  inline CLoginRes& operator=(const CLoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLoginRes& operator=(CLoginRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CLoginRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CLoginRes* internal_default_instance() {
    return reinterpret_cast<const CLoginRes*>(
               &_CLoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CLoginRes* other);
  friend void swap(CLoginRes& a, CLoginRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CLoginRes* New() const final {
    return CreateMaybeMessage<CLoginRes>(nullptr);
  }

  CLoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CLoginRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CLoginRes& from);
  void MergeFrom(const CLoginRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLoginRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CLoginRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CLoginRes_CLoginResType CLoginResType;
  static constexpr CLoginResType OK =
    CLoginRes_CLoginResType_OK;
  static constexpr CLoginResType ERROR =
    CLoginRes_CLoginResType_ERROR;
  static constexpr CLoginResType NOUSER =
    CLoginRes_CLoginResType_NOUSER;
  static inline bool CLoginResType_IsValid(int value) {
    return CLoginRes_CLoginResType_IsValid(value);
  }
  static constexpr CLoginResType CLoginResType_MIN =
    CLoginRes_CLoginResType_CLoginResType_MIN;
  static constexpr CLoginResType CLoginResType_MAX =
    CLoginRes_CLoginResType_CLoginResType_MAX;
  static constexpr int CLoginResType_ARRAYSIZE =
    CLoginRes_CLoginResType_CLoginResType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CLoginResType_descriptor() {
    return CLoginRes_CLoginResType_descriptor();
  }
  template<typename T>
  static inline const std::string& CLoginResType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CLoginResType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CLoginResType_Name.");
    return CLoginRes_CLoginResType_Name(enum_t_value);
  }
  static inline bool CLoginResType_Parse(const std::string& name,
      CLoginResType* value) {
    return CLoginRes_CLoginResType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // string rolename = 4;
  void clear_rolename();
  static const int kRolenameFieldNumber = 4;
  const std::string& rolename() const;
  void set_rolename(const std::string& value);
  void set_rolename(std::string&& value);
  void set_rolename(const char* value);
  void set_rolename(const char* value, size_t size);
  std::string* mutable_rolename();
  std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);

  // string username = 5;
  void clear_username();
  static const int kUsernameFieldNumber = 5;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // .cmsg.CLoginRes.CLoginResType res = 1;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::cmsg::CLoginRes_CLoginResType res() const;
  void set_res(::cmsg::CLoginRes_CLoginResType value);

  // int32 expired_time = 3;
  void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 expired_time() const;
  void set_expired_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CLoginRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  int res_;
  ::PROTOBUF_NAMESPACE_ID::int32 expired_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDirReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDirReq) */ {
 public:
  CDirReq();
  virtual ~CDirReq();

  CDirReq(const CDirReq& from);
  CDirReq(CDirReq&& from) noexcept
    : CDirReq() {
    *this = ::std::move(from);
  }

  inline CDirReq& operator=(const CDirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDirReq& operator=(CDirReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDirReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDirReq* internal_default_instance() {
    return reinterpret_cast<const CDirReq*>(
               &_CDirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CDirReq* other);
  friend void swap(CDirReq& a, CDirReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDirReq* New() const final {
    return CreateMaybeMessage<CDirReq>(nullptr);
  }

  CDirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDirReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDirReq& from);
  void MergeFrom(const CDirReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDirReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDirReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // @@protoc_insertion_point(class_scope:cmsg.CDirReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDirRes_CDir :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDirRes.CDir) */ {
 public:
  CDirRes_CDir();
  virtual ~CDirRes_CDir();

  CDirRes_CDir(const CDirRes_CDir& from);
  CDirRes_CDir(CDirRes_CDir&& from) noexcept
    : CDirRes_CDir() {
    *this = ::std::move(from);
  }

  inline CDirRes_CDir& operator=(const CDirRes_CDir& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDirRes_CDir& operator=(CDirRes_CDir&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDirRes_CDir& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDirRes_CDir* internal_default_instance() {
    return reinterpret_cast<const CDirRes_CDir*>(
               &_CDirRes_CDir_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CDirRes_CDir* other);
  friend void swap(CDirRes_CDir& a, CDirRes_CDir& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDirRes_CDir* New() const final {
    return CreateMaybeMessage<CDirRes_CDir>(nullptr);
  }

  CDirRes_CDir* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDirRes_CDir>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDirRes_CDir& from);
  void MergeFrom(const CDirRes_CDir& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDirRes_CDir* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDirRes.CDir";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // int32 filesize = 2;
  void clear_filesize();
  static const int kFilesizeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 filesize() const;
  void set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CDirRes.CDir)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::int32 filesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDirRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDirRes) */ {
 public:
  CDirRes();
  virtual ~CDirRes();

  CDirRes(const CDirRes& from);
  CDirRes(CDirRes&& from) noexcept
    : CDirRes() {
    *this = ::std::move(from);
  }

  inline CDirRes& operator=(const CDirRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDirRes& operator=(CDirRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDirRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDirRes* internal_default_instance() {
    return reinterpret_cast<const CDirRes*>(
               &_CDirRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CDirRes* other);
  friend void swap(CDirRes& a, CDirRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDirRes* New() const final {
    return CreateMaybeMessage<CDirRes>(nullptr);
  }

  CDirRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDirRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDirRes& from);
  void MergeFrom(const CDirRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDirRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDirRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CDirRes_CDir CDir;

  typedef CDirRes_CDirType CDirType;
  static constexpr CDirType OK =
    CDirRes_CDirType_OK;
  static constexpr CDirType ERROR =
    CDirRes_CDirType_ERROR;
  static constexpr CDirType NODIR =
    CDirRes_CDirType_NODIR;
  static inline bool CDirType_IsValid(int value) {
    return CDirRes_CDirType_IsValid(value);
  }
  static constexpr CDirType CDirType_MIN =
    CDirRes_CDirType_CDirType_MIN;
  static constexpr CDirType CDirType_MAX =
    CDirRes_CDirType_CDirType_MAX;
  static constexpr int CDirType_ARRAYSIZE =
    CDirRes_CDirType_CDirType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CDirType_descriptor() {
    return CDirRes_CDirType_descriptor();
  }
  template<typename T>
  static inline const std::string& CDirType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CDirType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CDirType_Name.");
    return CDirRes_CDirType_Name(enum_t_value);
  }
  static inline bool CDirType_Parse(const std::string& name,
      CDirType* value) {
    return CDirRes_CDirType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .cmsg.CDirRes.CDir dirs = 2;
  int dirs_size() const;
  void clear_dirs();
  static const int kDirsFieldNumber = 2;
  ::cmsg::CDirRes_CDir* mutable_dirs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CDirRes_CDir >*
      mutable_dirs();
  const ::cmsg::CDirRes_CDir& dirs(int index) const;
  ::cmsg::CDirRes_CDir* add_dirs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CDirRes_CDir >&
      dirs() const;

  // .cmsg.CDirRes.CDirType res = 1;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::cmsg::CDirRes_CDirType res() const;
  void set_res(::cmsg::CDirRes_CDirType value);

  // @@protoc_insertion_point(class_scope:cmsg.CDirRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CDirRes_CDir > dirs_;
  int res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CRegisterReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CRegisterReq) */ {
 public:
  CRegisterReq();
  virtual ~CRegisterReq();

  CRegisterReq(const CRegisterReq& from);
  CRegisterReq(CRegisterReq&& from) noexcept
    : CRegisterReq() {
    *this = ::std::move(from);
  }

  inline CRegisterReq& operator=(const CRegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRegisterReq& operator=(CRegisterReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CRegisterReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CRegisterReq* internal_default_instance() {
    return reinterpret_cast<const CRegisterReq*>(
               &_CRegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CRegisterReq* other);
  friend void swap(CRegisterReq& a, CRegisterReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CRegisterReq* New() const final {
    return CreateMaybeMessage<CRegisterReq>(nullptr);
  }

  CRegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CRegisterReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CRegisterReq& from);
  void MergeFrom(const CRegisterReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRegisterReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CRegisterReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CRegisterReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CMessageRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CMessageRes) */ {
 public:
  CMessageRes();
  virtual ~CMessageRes();

  CMessageRes(const CMessageRes& from);
  CMessageRes(CMessageRes&& from) noexcept
    : CMessageRes() {
    *this = ::std::move(from);
  }

  inline CMessageRes& operator=(const CMessageRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMessageRes& operator=(CMessageRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CMessageRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMessageRes* internal_default_instance() {
    return reinterpret_cast<const CMessageRes*>(
               &_CMessageRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMessageRes* other);
  friend void swap(CMessageRes& a, CMessageRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMessageRes* New() const final {
    return CreateMaybeMessage<CMessageRes>(nullptr);
  }

  CMessageRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMessageRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMessageRes& from);
  void MergeFrom(const CMessageRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMessageRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CMessageRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CMessageRes_CReturn CReturn;
  static constexpr CReturn OK =
    CMessageRes_CReturn_OK;
  static constexpr CReturn ERROR =
    CMessageRes_CReturn_ERROR;
  static inline bool CReturn_IsValid(int value) {
    return CMessageRes_CReturn_IsValid(value);
  }
  static constexpr CReturn CReturn_MIN =
    CMessageRes_CReturn_CReturn_MIN;
  static constexpr CReturn CReturn_MAX =
    CMessageRes_CReturn_CReturn_MAX;
  static constexpr int CReturn_ARRAYSIZE =
    CMessageRes_CReturn_CReturn_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CReturn_descriptor() {
    return CMessageRes_CReturn_descriptor();
  }
  template<typename T>
  static inline const std::string& CReturn_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CReturn>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CReturn_Name.");
    return CMessageRes_CReturn_Name(enum_t_value);
  }
  static inline bool CReturn_Parse(const std::string& name,
      CReturn* value) {
    return CMessageRes_CReturn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // .cmsg.CMessageRes.CReturn return = 1;
  void clear_return_();
  static const int kReturnFieldNumber = 1;
  ::cmsg::CMessageRes_CReturn return_() const;
  void set_return_(::cmsg::CMessageRes_CReturn value);

  // @@protoc_insertion_point(class_scope:cmsg.CMessageRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int return__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CGetServiceReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CGetServiceReq) */ {
 public:
  CGetServiceReq();
  virtual ~CGetServiceReq();

  CGetServiceReq(const CGetServiceReq& from);
  CGetServiceReq(CGetServiceReq&& from) noexcept
    : CGetServiceReq() {
    *this = ::std::move(from);
  }

  inline CGetServiceReq& operator=(const CGetServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGetServiceReq& operator=(CGetServiceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CGetServiceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CGetServiceReq* internal_default_instance() {
    return reinterpret_cast<const CGetServiceReq*>(
               &_CGetServiceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CGetServiceReq* other);
  friend void swap(CGetServiceReq& a, CGetServiceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CGetServiceReq* New() const final {
    return CreateMaybeMessage<CGetServiceReq>(nullptr);
  }

  CGetServiceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CGetServiceReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CGetServiceReq& from);
  void MergeFrom(const CGetServiceReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetServiceReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CGetServiceReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .cmsg.CServiceType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::cmsg::CServiceType type() const;
  void set_type(::cmsg::CServiceType value);

  // @@protoc_insertion_point(class_scope:cmsg.CGetServiceReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CServiceMap_CService :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CServiceMap.CService) */ {
 public:
  CServiceMap_CService();
  virtual ~CServiceMap_CService();

  CServiceMap_CService(const CServiceMap_CService& from);
  CServiceMap_CService(CServiceMap_CService&& from) noexcept
    : CServiceMap_CService() {
    *this = ::std::move(from);
  }

  inline CServiceMap_CService& operator=(const CServiceMap_CService& from) {
    CopyFrom(from);
    return *this;
  }
  inline CServiceMap_CService& operator=(CServiceMap_CService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CServiceMap_CService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CServiceMap_CService* internal_default_instance() {
    return reinterpret_cast<const CServiceMap_CService*>(
               &_CServiceMap_CService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CServiceMap_CService* other);
  friend void swap(CServiceMap_CService& a, CServiceMap_CService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CServiceMap_CService* New() const final {
    return CreateMaybeMessage<CServiceMap_CService>(nullptr);
  }

  CServiceMap_CService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CServiceMap_CService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CServiceMap_CService& from);
  void MergeFrom(const CServiceMap_CService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CServiceMap_CService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CServiceMap.CService";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);

  // int32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CServiceMap.CService)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CServiceMap_CServiceList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CServiceMap.CServiceList) */ {
 public:
  CServiceMap_CServiceList();
  virtual ~CServiceMap_CServiceList();

  CServiceMap_CServiceList(const CServiceMap_CServiceList& from);
  CServiceMap_CServiceList(CServiceMap_CServiceList&& from) noexcept
    : CServiceMap_CServiceList() {
    *this = ::std::move(from);
  }

  inline CServiceMap_CServiceList& operator=(const CServiceMap_CServiceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CServiceMap_CServiceList& operator=(CServiceMap_CServiceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CServiceMap_CServiceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CServiceMap_CServiceList* internal_default_instance() {
    return reinterpret_cast<const CServiceMap_CServiceList*>(
               &_CServiceMap_CServiceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CServiceMap_CServiceList* other);
  friend void swap(CServiceMap_CServiceList& a, CServiceMap_CServiceList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CServiceMap_CServiceList* New() const final {
    return CreateMaybeMessage<CServiceMap_CServiceList>(nullptr);
  }

  CServiceMap_CServiceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CServiceMap_CServiceList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CServiceMap_CServiceList& from);
  void MergeFrom(const CServiceMap_CServiceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CServiceMap_CServiceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CServiceMap.CServiceList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cmsg.CServiceMap.CService service = 1;
  int service_size() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  ::cmsg::CServiceMap_CService* mutable_service(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CServiceMap_CService >*
      mutable_service();
  const ::cmsg::CServiceMap_CService& service(int index) const;
  ::cmsg::CServiceMap_CService* add_service();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CServiceMap_CService >&
      service() const;

  // @@protoc_insertion_point(class_scope:cmsg.CServiceMap.CServiceList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CServiceMap_CService > service_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CServiceMap_ServiceMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CServiceMap_ServiceMapEntry_DoNotUse, 
    std::string, ::cmsg::CServiceMap_CServiceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CServiceMap_ServiceMapEntry_DoNotUse, 
    std::string, ::cmsg::CServiceMap_CServiceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  CServiceMap_ServiceMapEntry_DoNotUse();
  CServiceMap_ServiceMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CServiceMap_ServiceMapEntry_DoNotUse& other);
  static const CServiceMap_ServiceMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CServiceMap_ServiceMapEntry_DoNotUse*>(&_CServiceMap_ServiceMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cmsg.CServiceMap.ServiceMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[13];
  }

  public:
};

// -------------------------------------------------------------------

class CServiceMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CServiceMap) */ {
 public:
  CServiceMap();
  virtual ~CServiceMap();

  CServiceMap(const CServiceMap& from);
  CServiceMap(CServiceMap&& from) noexcept
    : CServiceMap() {
    *this = ::std::move(from);
  }

  inline CServiceMap& operator=(const CServiceMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline CServiceMap& operator=(CServiceMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CServiceMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CServiceMap* internal_default_instance() {
    return reinterpret_cast<const CServiceMap*>(
               &_CServiceMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CServiceMap* other);
  friend void swap(CServiceMap& a, CServiceMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CServiceMap* New() const final {
    return CreateMaybeMessage<CServiceMap>(nullptr);
  }

  CServiceMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CServiceMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CServiceMap& from);
  void MergeFrom(const CServiceMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CServiceMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CServiceMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CServiceMap_CService CService;
  typedef CServiceMap_CServiceList CServiceList;

  // accessors -------------------------------------------------------

  // map<string, .cmsg.CServiceMap.CServiceList> serviceMap = 1;
  int servicemap_size() const;
  void clear_servicemap();
  static const int kServiceMapFieldNumber = 1;
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::cmsg::CServiceMap_CServiceList >&
      servicemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::cmsg::CServiceMap_CServiceList >*
      mutable_servicemap();

  // .cmsg.CMessageRes res = 2;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 2;
  const ::cmsg::CMessageRes& res() const;
  ::cmsg::CMessageRes* release_res();
  ::cmsg::CMessageRes* mutable_res();
  void set_allocated_res(::cmsg::CMessageRes* res);

  // .cmsg.CServiceType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::cmsg::CServiceType type() const;
  void set_type(::cmsg::CServiceType value);

  // @@protoc_insertion_point(class_scope:cmsg.CServiceMap)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CServiceMap_ServiceMapEntry_DoNotUse,
      std::string, ::cmsg::CServiceMap_CServiceList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > servicemap_;
  ::cmsg::CMessageRes* res_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CConfig) */ {
 public:
  CConfig();
  virtual ~CConfig();

  CConfig(const CConfig& from);
  CConfig(CConfig&& from) noexcept
    : CConfig() {
    *this = ::std::move(from);
  }

  inline CConfig& operator=(const CConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CConfig& operator=(CConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CConfig* internal_default_instance() {
    return reinterpret_cast<const CConfig*>(
               &_CConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CConfig* other);
  friend void swap(CConfig& a, CConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CConfig* New() const final {
    return CreateMaybeMessage<CConfig>(nullptr);
  }

  CConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CConfig& from);
  void MergeFrom(const CConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serviceName = 1;
  void clear_servicename();
  static const int kServiceNameFieldNumber = 1;
  const std::string& servicename() const;
  void set_servicename(const std::string& value);
  void set_servicename(std::string&& value);
  void set_servicename(const char* value);
  void set_servicename(const char* value, size_t size);
  std::string* mutable_servicename();
  std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);

  // string serviceIp = 3;
  void clear_serviceip();
  static const int kServiceIpFieldNumber = 3;
  const std::string& serviceip() const;
  void set_serviceip(const std::string& value);
  void set_serviceip(std::string&& value);
  void set_serviceip(const char* value);
  void set_serviceip(const char* value, size_t size);
  std::string* mutable_serviceip();
  std::string* release_serviceip();
  void set_allocated_serviceip(std::string* serviceip);

  // bytes privatePb = 4;
  void clear_privatepb();
  static const int kPrivatePbFieldNumber = 4;
  const std::string& privatepb() const;
  void set_privatepb(const std::string& value);
  void set_privatepb(std::string&& value);
  void set_privatepb(const char* value);
  void set_privatepb(const void* value, size_t size);
  std::string* mutable_privatepb();
  std::string* release_privatepb();
  void set_allocated_privatepb(std::string* privatepb);

  // bytes proto = 5;
  void clear_proto();
  static const int kProtoFieldNumber = 5;
  const std::string& proto() const;
  void set_proto(const std::string& value);
  void set_proto(std::string&& value);
  void set_proto(const char* value);
  void set_proto(const void* value, size_t size);
  std::string* mutable_proto();
  std::string* release_proto();
  void set_allocated_proto(std::string* proto);

  // int32 servicePort = 2;
  void clear_serviceport();
  static const int kServicePortFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 serviceport() const;
  void set_serviceport(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatepb_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_;
  ::PROTOBUF_NAMESPACE_ID::int32 serviceport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDownloadconfigReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDownloadconfigReq) */ {
 public:
  CDownloadconfigReq();
  virtual ~CDownloadconfigReq();

  CDownloadconfigReq(const CDownloadconfigReq& from);
  CDownloadconfigReq(CDownloadconfigReq&& from) noexcept
    : CDownloadconfigReq() {
    *this = ::std::move(from);
  }

  inline CDownloadconfigReq& operator=(const CDownloadconfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDownloadconfigReq& operator=(CDownloadconfigReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDownloadconfigReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDownloadconfigReq* internal_default_instance() {
    return reinterpret_cast<const CDownloadconfigReq*>(
               &_CDownloadconfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CDownloadconfigReq* other);
  friend void swap(CDownloadconfigReq& a, CDownloadconfigReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDownloadconfigReq* New() const final {
    return CreateMaybeMessage<CDownloadconfigReq>(nullptr);
  }

  CDownloadconfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDownloadconfigReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDownloadconfigReq& from);
  void MergeFrom(const CDownloadconfigReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDownloadconfigReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDownloadconfigReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serviceIp = 2;
  void clear_serviceip();
  static const int kServiceIpFieldNumber = 2;
  const std::string& serviceip() const;
  void set_serviceip(const std::string& value);
  void set_serviceip(std::string&& value);
  void set_serviceip(const char* value);
  void set_serviceip(const char* value, size_t size);
  std::string* mutable_serviceip();
  std::string* release_serviceip();
  void set_allocated_serviceip(std::string* serviceip);

  // int32 servicePort = 1;
  void clear_serviceport();
  static const int kServicePortFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 serviceport() const;
  void set_serviceport(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CDownloadconfigReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceip_;
  ::PROTOBUF_NAMESPACE_ID::int32 serviceport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CConfigList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CConfigList) */ {
 public:
  CConfigList();
  virtual ~CConfigList();

  CConfigList(const CConfigList& from);
  CConfigList(CConfigList&& from) noexcept
    : CConfigList() {
    *this = ::std::move(from);
  }

  inline CConfigList& operator=(const CConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CConfigList& operator=(CConfigList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CConfigList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CConfigList* internal_default_instance() {
    return reinterpret_cast<const CConfigList*>(
               &_CConfigList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CConfigList* other);
  friend void swap(CConfigList& a, CConfigList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CConfigList* New() const final {
    return CreateMaybeMessage<CConfigList>(nullptr);
  }

  CConfigList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CConfigList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CConfigList& from);
  void MergeFrom(const CConfigList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CConfigList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CConfigList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cmsg.CConfig config = 1;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  ::cmsg::CConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CConfig >*
      mutable_config();
  const ::cmsg::CConfig& config(int index) const;
  ::cmsg::CConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:cmsg.CConfigList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CConfig > config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDownloadAllConfigReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDownloadAllConfigReq) */ {
 public:
  CDownloadAllConfigReq();
  virtual ~CDownloadAllConfigReq();

  CDownloadAllConfigReq(const CDownloadAllConfigReq& from);
  CDownloadAllConfigReq(CDownloadAllConfigReq&& from) noexcept
    : CDownloadAllConfigReq() {
    *this = ::std::move(from);
  }

  inline CDownloadAllConfigReq& operator=(const CDownloadAllConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDownloadAllConfigReq& operator=(CDownloadAllConfigReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDownloadAllConfigReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDownloadAllConfigReq* internal_default_instance() {
    return reinterpret_cast<const CDownloadAllConfigReq*>(
               &_CDownloadAllConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CDownloadAllConfigReq* other);
  friend void swap(CDownloadAllConfigReq& a, CDownloadAllConfigReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDownloadAllConfigReq* New() const final {
    return CreateMaybeMessage<CDownloadAllConfigReq>(nullptr);
  }

  CDownloadAllConfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDownloadAllConfigReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDownloadAllConfigReq& from);
  void MergeFrom(const CDownloadAllConfigReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDownloadAllConfigReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDownloadAllConfigReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 page = 1;
  void clear_page();
  static const int kPageFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 pageCount = 2;
  void clear_pagecount();
  static const int kPageCountFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 pagecount() const;
  void set_pagecount(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:cmsg.CDownloadAllConfigReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 page_;
  ::PROTOBUF_NAMESPACE_ID::int32 pagecount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CGatewayConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CGatewayConfig) */ {
 public:
  CGatewayConfig();
  virtual ~CGatewayConfig();

  CGatewayConfig(const CGatewayConfig& from);
  CGatewayConfig(CGatewayConfig&& from) noexcept
    : CGatewayConfig() {
    *this = ::std::move(from);
  }

  inline CGatewayConfig& operator=(const CGatewayConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGatewayConfig& operator=(CGatewayConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CGatewayConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CGatewayConfig* internal_default_instance() {
    return reinterpret_cast<const CGatewayConfig*>(
               &_CGatewayConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CGatewayConfig* other);
  friend void swap(CGatewayConfig& a, CGatewayConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CGatewayConfig* New() const final {
    return CreateMaybeMessage<CGatewayConfig>(nullptr);
  }

  CGatewayConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CGatewayConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CGatewayConfig& from);
  void MergeFrom(const CGatewayConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGatewayConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CGatewayConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string crtPath = 2;
  void clear_crtpath();
  static const int kCrtPathFieldNumber = 2;
  const std::string& crtpath() const;
  void set_crtpath(const std::string& value);
  void set_crtpath(std::string&& value);
  void set_crtpath(const char* value);
  void set_crtpath(const char* value, size_t size);
  std::string* mutable_crtpath();
  std::string* release_crtpath();
  void set_allocated_crtpath(std::string* crtpath);

  // string keyPath = 3;
  void clear_keypath();
  static const int kKeyPathFieldNumber = 3;
  const std::string& keypath() const;
  void set_keypath(const std::string& value);
  void set_keypath(std::string&& value);
  void set_keypath(const char* value);
  void set_keypath(const char* value, size_t size);
  std::string* mutable_keypath();
  std::string* release_keypath();
  void set_allocated_keypath(std::string* keypath);

  // string caPath = 4;
  void clear_capath();
  static const int kCaPathFieldNumber = 4;
  const std::string& capath() const;
  void set_capath(const std::string& value);
  void set_capath(std::string&& value);
  void set_capath(const char* value);
  void set_capath(const char* value, size_t size);
  std::string* mutable_capath();
  std::string* release_capath();
  void set_allocated_capath(std::string* capath);

  // bool isSSL = 1;
  void clear_isssl();
  static const int kIsSSLFieldNumber = 1;
  bool isssl() const;
  void set_isssl(bool value);

  // @@protoc_insertion_point(class_scope:cmsg.CGatewayConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crtpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keypath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capath_;
  bool isssl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CAddUserReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CAddUserReq) */ {
 public:
  CAddUserReq();
  virtual ~CAddUserReq();

  CAddUserReq(const CAddUserReq& from);
  CAddUserReq(CAddUserReq&& from) noexcept
    : CAddUserReq() {
    *this = ::std::move(from);
  }

  inline CAddUserReq& operator=(const CAddUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAddUserReq& operator=(CAddUserReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CAddUserReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAddUserReq* internal_default_instance() {
    return reinterpret_cast<const CAddUserReq*>(
               &_CAddUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CAddUserReq* other);
  friend void swap(CAddUserReq& a, CAddUserReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAddUserReq* New() const final {
    return CreateMaybeMessage<CAddUserReq>(nullptr);
  }

  CAddUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CAddUserReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CAddUserReq& from);
  void MergeFrom(const CAddUserReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAddUserReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CAddUserReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // string rolename = 3;
  void clear_rolename();
  static const int kRolenameFieldNumber = 3;
  const std::string& rolename() const;
  void set_rolename(const std::string& value);
  void set_rolename(std::string&& value);
  void set_rolename(const char* value);
  void set_rolename(const char* value, size_t size);
  std::string* mutable_rolename();
  std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);

  // @@protoc_insertion_point(class_scope:cmsg.CAddUserReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// -------------------------------------------------------------------

class CDirConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cmsg.CDirConfig) */ {
 public:
  CDirConfig();
  virtual ~CDirConfig();

  CDirConfig(const CDirConfig& from);
  CDirConfig(CDirConfig&& from) noexcept
    : CDirConfig() {
    *this = ::std::move(from);
  }

  inline CDirConfig& operator=(const CDirConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDirConfig& operator=(CDirConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CDirConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDirConfig* internal_default_instance() {
    return reinterpret_cast<const CDirConfig*>(
               &_CDirConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CDirConfig* other);
  friend void swap(CDirConfig& a, CDirConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDirConfig* New() const final {
    return CreateMaybeMessage<CDirConfig>(nullptr);
  }

  CDirConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CDirConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CDirConfig& from);
  void MergeFrom(const CDirConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDirConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cmsg.CDirConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cmsgcom_2eproto);
    return ::descriptor_table_cmsgcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string root = 1;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const std::string& root() const;
  void set_root(const std::string& value);
  void set_root(std::string&& value);
  void set_root(const char* value);
  void set_root(const char* value, size_t size);
  std::string* mutable_root();
  std::string* release_root();
  void set_allocated_root(std::string* root);

  // @@protoc_insertion_point(class_scope:cmsg.CDirConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmsgcom_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgHead

// int32 msg_size = 1;
inline void CMsgHead::clear_msg_size() {
  msg_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsgHead::msg_size() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHead.msg_size)
  return msg_size_;
}
inline void CMsgHead::set_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  msg_size_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CMsgHead.msg_size)
}

// .cmsg.CMsgType msg_type = 2;
inline void CMsgHead::clear_msg_type() {
  msg_type_ = 0;
}
inline ::cmsg::CMsgType CMsgHead::msg_type() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHead.msg_type)
  return static_cast< ::cmsg::CMsgType >(msg_type_);
}
inline void CMsgHead::set_msg_type(::cmsg::CMsgType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CMsgHead.msg_type)
}

// string token = 3;
inline void CMsgHead::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CMsgHead::token() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHead.token)
  return token_.GetNoArena();
}
inline void CMsgHead::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CMsgHead.token)
}
inline void CMsgHead::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CMsgHead.token)
}
inline void CMsgHead::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CMsgHead.token)
}
inline void CMsgHead::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CMsgHead.token)
}
inline std::string* CMsgHead::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CMsgHead.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMsgHead::release_token() {
  // @@protoc_insertion_point(field_release:cmsg.CMsgHead.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgHead::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CMsgHead.token)
}

// string service_name = 4;
inline void CMsgHead::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CMsgHead::service_name() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHead.service_name)
  return service_name_.GetNoArena();
}
inline void CMsgHead::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CMsgHead.service_name)
}
inline void CMsgHead::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CMsgHead.service_name)
}
inline void CMsgHead::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CMsgHead.service_name)
}
inline void CMsgHead::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CMsgHead.service_name)
}
inline std::string* CMsgHead::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CMsgHead.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMsgHead::release_service_name() {
  // @@protoc_insertion_point(field_release:cmsg.CMsgHead.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgHead::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CMsgHead.service_name)
}

// int64 msg_id = 5;
inline void CMsgHead::clear_msg_id() {
  msg_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CMsgHead::msg_id() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHead.msg_id)
  return msg_id_;
}
inline void CMsgHead::set_msg_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CMsgHead.msg_id)
}

// -------------------------------------------------------------------

// CMsgHeart

// int64 count = 1;
inline void CMsgHeart::clear_count() {
  count_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CMsgHeart::count() const {
  // @@protoc_insertion_point(field_get:cmsg.CMsgHeart.count)
  return count_;
}
inline void CMsgHeart::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CMsgHeart.count)
}

// -------------------------------------------------------------------

// CAddLogReq

// string service_ip = 1;
inline void CAddLogReq::clear_service_ip() {
  service_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddLogReq::service_ip() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.service_ip)
  return service_ip_.GetNoArena();
}
inline void CAddLogReq::set_service_ip(const std::string& value) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.service_ip)
}
inline void CAddLogReq::set_service_ip(std::string&& value) {
  
  service_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddLogReq.service_ip)
}
inline void CAddLogReq::set_service_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddLogReq.service_ip)
}
inline void CAddLogReq::set_service_ip(const char* value, size_t size) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddLogReq.service_ip)
}
inline std::string* CAddLogReq::mutable_service_ip() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddLogReq.service_ip)
  return service_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddLogReq::release_service_ip() {
  // @@protoc_insertion_point(field_release:cmsg.CAddLogReq.service_ip)
  
  return service_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddLogReq::set_allocated_service_ip(std::string* service_ip) {
  if (service_ip != nullptr) {
    
  } else {
    
  }
  service_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_ip);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddLogReq.service_ip)
}

// int32 service_port = 2;
inline void CAddLogReq::clear_service_port() {
  service_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAddLogReq::service_port() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.service_port)
  return service_port_;
}
inline void CAddLogReq::set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  service_port_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.service_port)
}

// string service_name = 3;
inline void CAddLogReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddLogReq::service_name() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.service_name)
  return service_name_.GetNoArena();
}
inline void CAddLogReq::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.service_name)
}
inline void CAddLogReq::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddLogReq.service_name)
}
inline void CAddLogReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddLogReq.service_name)
}
inline void CAddLogReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddLogReq.service_name)
}
inline std::string* CAddLogReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddLogReq.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddLogReq::release_service_name() {
  // @@protoc_insertion_point(field_release:cmsg.CAddLogReq.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddLogReq::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddLogReq.service_name)
}

// bytes log_txt = 4;
inline void CAddLogReq::clear_log_txt() {
  log_txt_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddLogReq::log_txt() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.log_txt)
  return log_txt_.GetNoArena();
}
inline void CAddLogReq::set_log_txt(const std::string& value) {
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.log_txt)
}
inline void CAddLogReq::set_log_txt(std::string&& value) {
  
  log_txt_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddLogReq.log_txt)
}
inline void CAddLogReq::set_log_txt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddLogReq.log_txt)
}
inline void CAddLogReq::set_log_txt(const void* value, size_t size) {
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddLogReq.log_txt)
}
inline std::string* CAddLogReq::mutable_log_txt() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddLogReq.log_txt)
  return log_txt_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddLogReq::release_log_txt() {
  // @@protoc_insertion_point(field_release:cmsg.CAddLogReq.log_txt)
  
  return log_txt_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddLogReq::set_allocated_log_txt(std::string* log_txt) {
  if (log_txt != nullptr) {
    
  } else {
    
  }
  log_txt_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_txt);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddLogReq.log_txt)
}

// int32 log_time = 5;
inline void CAddLogReq::clear_log_time() {
  log_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAddLogReq::log_time() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.log_time)
  return log_time_;
}
inline void CAddLogReq::set_log_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  log_time_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.log_time)
}

// .cmsg.CLogLevel log_level = 6;
inline void CAddLogReq::clear_log_level() {
  log_level_ = 0;
}
inline ::cmsg::CLogLevel CAddLogReq::log_level() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.log_level)
  return static_cast< ::cmsg::CLogLevel >(log_level_);
}
inline void CAddLogReq::set_log_level(::cmsg::CLogLevel value) {
  
  log_level_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.log_level)
}

// string filename = 7;
inline void CAddLogReq::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddLogReq::filename() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.filename)
  return filename_.GetNoArena();
}
inline void CAddLogReq::set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.filename)
}
inline void CAddLogReq::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddLogReq.filename)
}
inline void CAddLogReq::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddLogReq.filename)
}
inline void CAddLogReq::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddLogReq.filename)
}
inline std::string* CAddLogReq::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddLogReq.filename)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddLogReq::release_filename() {
  // @@protoc_insertion_point(field_release:cmsg.CAddLogReq.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddLogReq::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddLogReq.filename)
}

// int32 line = 8;
inline void CAddLogReq::clear_line() {
  line_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAddLogReq::line() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddLogReq.line)
  return line_;
}
inline void CAddLogReq::set_line(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  line_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CAddLogReq.line)
}

// -------------------------------------------------------------------

// CLoginReq

// string username = 1;
inline void CLoginReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CLoginReq::username() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginReq.username)
  return username_.GetNoArena();
}
inline void CLoginReq::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CLoginReq.username)
}
inline void CLoginReq::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CLoginReq.username)
}
inline void CLoginReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CLoginReq.username)
}
inline void CLoginReq::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CLoginReq.username)
}
inline std::string* CLoginReq::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CLoginReq.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CLoginReq::release_username() {
  // @@protoc_insertion_point(field_release:cmsg.CLoginReq.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CLoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CLoginReq.username)
}

// string password = 2;
inline void CLoginReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CLoginReq::password() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginReq.password)
  return password_.GetNoArena();
}
inline void CLoginReq::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CLoginReq.password)
}
inline void CLoginReq::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CLoginReq.password)
}
inline void CLoginReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CLoginReq.password)
}
inline void CLoginReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CLoginReq.password)
}
inline std::string* CLoginReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CLoginReq.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CLoginReq::release_password() {
  // @@protoc_insertion_point(field_release:cmsg.CLoginReq.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CLoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CLoginReq.password)
}

// -------------------------------------------------------------------

// CLoginRes

// .cmsg.CLoginRes.CLoginResType res = 1;
inline void CLoginRes::clear_res() {
  res_ = 0;
}
inline ::cmsg::CLoginRes_CLoginResType CLoginRes::res() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginRes.res)
  return static_cast< ::cmsg::CLoginRes_CLoginResType >(res_);
}
inline void CLoginRes::set_res(::cmsg::CLoginRes_CLoginResType value) {
  
  res_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CLoginRes.res)
}

// string token = 2;
inline void CLoginRes::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CLoginRes::token() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginRes.token)
  return token_.GetNoArena();
}
inline void CLoginRes::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CLoginRes.token)
}
inline void CLoginRes::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CLoginRes.token)
}
inline void CLoginRes::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CLoginRes.token)
}
inline void CLoginRes::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CLoginRes.token)
}
inline std::string* CLoginRes::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CLoginRes.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CLoginRes::release_token() {
  // @@protoc_insertion_point(field_release:cmsg.CLoginRes.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CLoginRes::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CLoginRes.token)
}

// int32 expired_time = 3;
inline void CLoginRes::clear_expired_time() {
  expired_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoginRes::expired_time() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginRes.expired_time)
  return expired_time_;
}
inline void CLoginRes::set_expired_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expired_time_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CLoginRes.expired_time)
}

// string rolename = 4;
inline void CLoginRes::clear_rolename() {
  rolename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CLoginRes::rolename() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginRes.rolename)
  return rolename_.GetNoArena();
}
inline void CLoginRes::set_rolename(const std::string& value) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CLoginRes.rolename)
}
inline void CLoginRes::set_rolename(std::string&& value) {
  
  rolename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CLoginRes.rolename)
}
inline void CLoginRes::set_rolename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CLoginRes.rolename)
}
inline void CLoginRes::set_rolename(const char* value, size_t size) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CLoginRes.rolename)
}
inline std::string* CLoginRes::mutable_rolename() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CLoginRes.rolename)
  return rolename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CLoginRes::release_rolename() {
  // @@protoc_insertion_point(field_release:cmsg.CLoginRes.rolename)
  
  return rolename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CLoginRes::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CLoginRes.rolename)
}

// string username = 5;
inline void CLoginRes::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CLoginRes::username() const {
  // @@protoc_insertion_point(field_get:cmsg.CLoginRes.username)
  return username_.GetNoArena();
}
inline void CLoginRes::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CLoginRes.username)
}
inline void CLoginRes::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CLoginRes.username)
}
inline void CLoginRes::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CLoginRes.username)
}
inline void CLoginRes::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CLoginRes.username)
}
inline std::string* CLoginRes::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CLoginRes.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CLoginRes::release_username() {
  // @@protoc_insertion_point(field_release:cmsg.CLoginRes.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CLoginRes::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CLoginRes.username)
}

// -------------------------------------------------------------------

// CDirReq

// string path = 1;
inline void CDirReq::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CDirReq::path() const {
  // @@protoc_insertion_point(field_get:cmsg.CDirReq.path)
  return path_.GetNoArena();
}
inline void CDirReq::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CDirReq.path)
}
inline void CDirReq::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CDirReq.path)
}
inline void CDirReq::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CDirReq.path)
}
inline void CDirReq::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CDirReq.path)
}
inline std::string* CDirReq::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CDirReq.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CDirReq::release_path() {
  // @@protoc_insertion_point(field_release:cmsg.CDirReq.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CDirReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CDirReq.path)
}

// -------------------------------------------------------------------

// CDirRes_CDir

// string filename = 1;
inline void CDirRes_CDir::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CDirRes_CDir::filename() const {
  // @@protoc_insertion_point(field_get:cmsg.CDirRes.CDir.filename)
  return filename_.GetNoArena();
}
inline void CDirRes_CDir::set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CDirRes.CDir.filename)
}
inline void CDirRes_CDir::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CDirRes.CDir.filename)
}
inline void CDirRes_CDir::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CDirRes.CDir.filename)
}
inline void CDirRes_CDir::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CDirRes.CDir.filename)
}
inline std::string* CDirRes_CDir::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CDirRes.CDir.filename)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CDirRes_CDir::release_filename() {
  // @@protoc_insertion_point(field_release:cmsg.CDirRes.CDir.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CDirRes_CDir::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CDirRes.CDir.filename)
}

// int32 filesize = 2;
inline void CDirRes_CDir::clear_filesize() {
  filesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CDirRes_CDir::filesize() const {
  // @@protoc_insertion_point(field_get:cmsg.CDirRes.CDir.filesize)
  return filesize_;
}
inline void CDirRes_CDir::set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  filesize_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CDirRes.CDir.filesize)
}

// -------------------------------------------------------------------

// CDirRes

// .cmsg.CDirRes.CDirType res = 1;
inline void CDirRes::clear_res() {
  res_ = 0;
}
inline ::cmsg::CDirRes_CDirType CDirRes::res() const {
  // @@protoc_insertion_point(field_get:cmsg.CDirRes.res)
  return static_cast< ::cmsg::CDirRes_CDirType >(res_);
}
inline void CDirRes::set_res(::cmsg::CDirRes_CDirType value) {
  
  res_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CDirRes.res)
}

// repeated .cmsg.CDirRes.CDir dirs = 2;
inline int CDirRes::dirs_size() const {
  return dirs_.size();
}
inline void CDirRes::clear_dirs() {
  dirs_.Clear();
}
inline ::cmsg::CDirRes_CDir* CDirRes::mutable_dirs(int index) {
  // @@protoc_insertion_point(field_mutable:cmsg.CDirRes.dirs)
  return dirs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CDirRes_CDir >*
CDirRes::mutable_dirs() {
  // @@protoc_insertion_point(field_mutable_list:cmsg.CDirRes.dirs)
  return &dirs_;
}
inline const ::cmsg::CDirRes_CDir& CDirRes::dirs(int index) const {
  // @@protoc_insertion_point(field_get:cmsg.CDirRes.dirs)
  return dirs_.Get(index);
}
inline ::cmsg::CDirRes_CDir* CDirRes::add_dirs() {
  // @@protoc_insertion_point(field_add:cmsg.CDirRes.dirs)
  return dirs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CDirRes_CDir >&
CDirRes::dirs() const {
  // @@protoc_insertion_point(field_list:cmsg.CDirRes.dirs)
  return dirs_;
}

// -------------------------------------------------------------------

// CRegisterReq

// string name = 1;
inline void CRegisterReq::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CRegisterReq::name() const {
  // @@protoc_insertion_point(field_get:cmsg.CRegisterReq.name)
  return name_.GetNoArena();
}
inline void CRegisterReq::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CRegisterReq.name)
}
inline void CRegisterReq::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CRegisterReq.name)
}
inline void CRegisterReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CRegisterReq.name)
}
inline void CRegisterReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CRegisterReq.name)
}
inline std::string* CRegisterReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CRegisterReq.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CRegisterReq::release_name() {
  // @@protoc_insertion_point(field_release:cmsg.CRegisterReq.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CRegisterReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CRegisterReq.name)
}

// int32 port = 2;
inline void CRegisterReq::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CRegisterReq::port() const {
  // @@protoc_insertion_point(field_get:cmsg.CRegisterReq.port)
  return port_;
}
inline void CRegisterReq::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CRegisterReq.port)
}

// string ip = 3;
inline void CRegisterReq::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CRegisterReq::ip() const {
  // @@protoc_insertion_point(field_get:cmsg.CRegisterReq.ip)
  return ip_.GetNoArena();
}
inline void CRegisterReq::set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CRegisterReq.ip)
}
inline void CRegisterReq::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CRegisterReq.ip)
}
inline void CRegisterReq::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CRegisterReq.ip)
}
inline void CRegisterReq::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CRegisterReq.ip)
}
inline std::string* CRegisterReq::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CRegisterReq.ip)
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CRegisterReq::release_ip() {
  // @@protoc_insertion_point(field_release:cmsg.CRegisterReq.ip)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CRegisterReq::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CRegisterReq.ip)
}

// -------------------------------------------------------------------

// CMessageRes

// .cmsg.CMessageRes.CReturn return = 1;
inline void CMessageRes::clear_return_() {
  return__ = 0;
}
inline ::cmsg::CMessageRes_CReturn CMessageRes::return_() const {
  // @@protoc_insertion_point(field_get:cmsg.CMessageRes.return)
  return static_cast< ::cmsg::CMessageRes_CReturn >(return__);
}
inline void CMessageRes::set_return_(::cmsg::CMessageRes_CReturn value) {
  
  return__ = value;
  // @@protoc_insertion_point(field_set:cmsg.CMessageRes.return)
}

// bytes msg = 2;
inline void CMessageRes::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CMessageRes::msg() const {
  // @@protoc_insertion_point(field_get:cmsg.CMessageRes.msg)
  return msg_.GetNoArena();
}
inline void CMessageRes::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CMessageRes.msg)
}
inline void CMessageRes::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CMessageRes.msg)
}
inline void CMessageRes::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CMessageRes.msg)
}
inline void CMessageRes::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CMessageRes.msg)
}
inline std::string* CMessageRes::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CMessageRes.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CMessageRes::release_msg() {
  // @@protoc_insertion_point(field_release:cmsg.CMessageRes.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CMessageRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CMessageRes.msg)
}

// -------------------------------------------------------------------

// CGetServiceReq

// string name = 1;
inline void CGetServiceReq::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CGetServiceReq::name() const {
  // @@protoc_insertion_point(field_get:cmsg.CGetServiceReq.name)
  return name_.GetNoArena();
}
inline void CGetServiceReq::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CGetServiceReq.name)
}
inline void CGetServiceReq::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CGetServiceReq.name)
}
inline void CGetServiceReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CGetServiceReq.name)
}
inline void CGetServiceReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CGetServiceReq.name)
}
inline std::string* CGetServiceReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CGetServiceReq.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CGetServiceReq::release_name() {
  // @@protoc_insertion_point(field_release:cmsg.CGetServiceReq.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CGetServiceReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CGetServiceReq.name)
}

// .cmsg.CServiceType type = 2;
inline void CGetServiceReq::clear_type() {
  type_ = 0;
}
inline ::cmsg::CServiceType CGetServiceReq::type() const {
  // @@protoc_insertion_point(field_get:cmsg.CGetServiceReq.type)
  return static_cast< ::cmsg::CServiceType >(type_);
}
inline void CGetServiceReq::set_type(::cmsg::CServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CGetServiceReq.type)
}

// -------------------------------------------------------------------

// CServiceMap_CService

// string name = 1;
inline void CServiceMap_CService::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CServiceMap_CService::name() const {
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.CService.name)
  return name_.GetNoArena();
}
inline void CServiceMap_CService::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CServiceMap.CService.name)
}
inline void CServiceMap_CService::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CServiceMap.CService.name)
}
inline void CServiceMap_CService::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CServiceMap.CService.name)
}
inline void CServiceMap_CService::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CServiceMap.CService.name)
}
inline std::string* CServiceMap_CService::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CServiceMap.CService.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CServiceMap_CService::release_name() {
  // @@protoc_insertion_point(field_release:cmsg.CServiceMap.CService.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CServiceMap_CService::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CServiceMap.CService.name)
}

// string ip = 2;
inline void CServiceMap_CService::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CServiceMap_CService::ip() const {
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.CService.ip)
  return ip_.GetNoArena();
}
inline void CServiceMap_CService::set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CServiceMap.CService.ip)
}
inline void CServiceMap_CService::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CServiceMap.CService.ip)
}
inline void CServiceMap_CService::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CServiceMap.CService.ip)
}
inline void CServiceMap_CService::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CServiceMap.CService.ip)
}
inline std::string* CServiceMap_CService::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CServiceMap.CService.ip)
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CServiceMap_CService::release_ip() {
  // @@protoc_insertion_point(field_release:cmsg.CServiceMap.CService.ip)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CServiceMap_CService::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CServiceMap.CService.ip)
}

// int32 port = 3;
inline void CServiceMap_CService::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CServiceMap_CService::port() const {
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.CService.port)
  return port_;
}
inline void CServiceMap_CService::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CServiceMap.CService.port)
}

// -------------------------------------------------------------------

// CServiceMap_CServiceList

// repeated .cmsg.CServiceMap.CService service = 1;
inline int CServiceMap_CServiceList::service_size() const {
  return service_.size();
}
inline void CServiceMap_CServiceList::clear_service() {
  service_.Clear();
}
inline ::cmsg::CServiceMap_CService* CServiceMap_CServiceList::mutable_service(int index) {
  // @@protoc_insertion_point(field_mutable:cmsg.CServiceMap.CServiceList.service)
  return service_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CServiceMap_CService >*
CServiceMap_CServiceList::mutable_service() {
  // @@protoc_insertion_point(field_mutable_list:cmsg.CServiceMap.CServiceList.service)
  return &service_;
}
inline const ::cmsg::CServiceMap_CService& CServiceMap_CServiceList::service(int index) const {
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.CServiceList.service)
  return service_.Get(index);
}
inline ::cmsg::CServiceMap_CService* CServiceMap_CServiceList::add_service() {
  // @@protoc_insertion_point(field_add:cmsg.CServiceMap.CServiceList.service)
  return service_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CServiceMap_CService >&
CServiceMap_CServiceList::service() const {
  // @@protoc_insertion_point(field_list:cmsg.CServiceMap.CServiceList.service)
  return service_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CServiceMap

// map<string, .cmsg.CServiceMap.CServiceList> serviceMap = 1;
inline int CServiceMap::servicemap_size() const {
  return servicemap_.size();
}
inline void CServiceMap::clear_servicemap() {
  servicemap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::cmsg::CServiceMap_CServiceList >&
CServiceMap::servicemap() const {
  // @@protoc_insertion_point(field_map:cmsg.CServiceMap.serviceMap)
  return servicemap_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::cmsg::CServiceMap_CServiceList >*
CServiceMap::mutable_servicemap() {
  // @@protoc_insertion_point(field_mutable_map:cmsg.CServiceMap.serviceMap)
  return servicemap_.MutableMap();
}

// .cmsg.CMessageRes res = 2;
inline bool CServiceMap::has_res() const {
  return this != internal_default_instance() && res_ != nullptr;
}
inline void CServiceMap::clear_res() {
  if (GetArenaNoVirtual() == nullptr && res_ != nullptr) {
    delete res_;
  }
  res_ = nullptr;
}
inline const ::cmsg::CMessageRes& CServiceMap::res() const {
  const ::cmsg::CMessageRes* p = res_;
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.res)
  return p != nullptr ? *p : *reinterpret_cast<const ::cmsg::CMessageRes*>(
      &::cmsg::_CMessageRes_default_instance_);
}
inline ::cmsg::CMessageRes* CServiceMap::release_res() {
  // @@protoc_insertion_point(field_release:cmsg.CServiceMap.res)
  
  ::cmsg::CMessageRes* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::cmsg::CMessageRes* CServiceMap::mutable_res() {
  
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::cmsg::CMessageRes>(GetArenaNoVirtual());
    res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cmsg.CServiceMap.res)
  return res_;
}
inline void CServiceMap::set_allocated_res(::cmsg::CMessageRes* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    
  } else {
    
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:cmsg.CServiceMap.res)
}

// .cmsg.CServiceType type = 3;
inline void CServiceMap::clear_type() {
  type_ = 0;
}
inline ::cmsg::CServiceType CServiceMap::type() const {
  // @@protoc_insertion_point(field_get:cmsg.CServiceMap.type)
  return static_cast< ::cmsg::CServiceType >(type_);
}
inline void CServiceMap::set_type(::cmsg::CServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CServiceMap.type)
}

// -------------------------------------------------------------------

// CConfig

// string serviceName = 1;
inline void CConfig::clear_servicename() {
  servicename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CConfig::servicename() const {
  // @@protoc_insertion_point(field_get:cmsg.CConfig.serviceName)
  return servicename_.GetNoArena();
}
inline void CConfig::set_servicename(const std::string& value) {
  
  servicename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CConfig.serviceName)
}
inline void CConfig::set_servicename(std::string&& value) {
  
  servicename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CConfig.serviceName)
}
inline void CConfig::set_servicename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  servicename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CConfig.serviceName)
}
inline void CConfig::set_servicename(const char* value, size_t size) {
  
  servicename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CConfig.serviceName)
}
inline std::string* CConfig::mutable_servicename() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CConfig.serviceName)
  return servicename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CConfig::release_servicename() {
  // @@protoc_insertion_point(field_release:cmsg.CConfig.serviceName)
  
  return servicename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CConfig::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  servicename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servicename);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CConfig.serviceName)
}

// int32 servicePort = 2;
inline void CConfig::clear_serviceport() {
  serviceport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CConfig::serviceport() const {
  // @@protoc_insertion_point(field_get:cmsg.CConfig.servicePort)
  return serviceport_;
}
inline void CConfig::set_serviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  serviceport_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CConfig.servicePort)
}

// string serviceIp = 3;
inline void CConfig::clear_serviceip() {
  serviceip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CConfig::serviceip() const {
  // @@protoc_insertion_point(field_get:cmsg.CConfig.serviceIp)
  return serviceip_.GetNoArena();
}
inline void CConfig::set_serviceip(const std::string& value) {
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CConfig.serviceIp)
}
inline void CConfig::set_serviceip(std::string&& value) {
  
  serviceip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CConfig.serviceIp)
}
inline void CConfig::set_serviceip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CConfig.serviceIp)
}
inline void CConfig::set_serviceip(const char* value, size_t size) {
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CConfig.serviceIp)
}
inline std::string* CConfig::mutable_serviceip() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CConfig.serviceIp)
  return serviceip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CConfig::release_serviceip() {
  // @@protoc_insertion_point(field_release:cmsg.CConfig.serviceIp)
  
  return serviceip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CConfig::set_allocated_serviceip(std::string* serviceip) {
  if (serviceip != nullptr) {
    
  } else {
    
  }
  serviceip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serviceip);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CConfig.serviceIp)
}

// bytes privatePb = 4;
inline void CConfig::clear_privatepb() {
  privatepb_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CConfig::privatepb() const {
  // @@protoc_insertion_point(field_get:cmsg.CConfig.privatePb)
  return privatepb_.GetNoArena();
}
inline void CConfig::set_privatepb(const std::string& value) {
  
  privatepb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CConfig.privatePb)
}
inline void CConfig::set_privatepb(std::string&& value) {
  
  privatepb_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CConfig.privatePb)
}
inline void CConfig::set_privatepb(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  privatepb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CConfig.privatePb)
}
inline void CConfig::set_privatepb(const void* value, size_t size) {
  
  privatepb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CConfig.privatePb)
}
inline std::string* CConfig::mutable_privatepb() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CConfig.privatePb)
  return privatepb_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CConfig::release_privatepb() {
  // @@protoc_insertion_point(field_release:cmsg.CConfig.privatePb)
  
  return privatepb_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CConfig::set_allocated_privatepb(std::string* privatepb) {
  if (privatepb != nullptr) {
    
  } else {
    
  }
  privatepb_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatepb);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CConfig.privatePb)
}

// bytes proto = 5;
inline void CConfig::clear_proto() {
  proto_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CConfig::proto() const {
  // @@protoc_insertion_point(field_get:cmsg.CConfig.proto)
  return proto_.GetNoArena();
}
inline void CConfig::set_proto(const std::string& value) {
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CConfig.proto)
}
inline void CConfig::set_proto(std::string&& value) {
  
  proto_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CConfig.proto)
}
inline void CConfig::set_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CConfig.proto)
}
inline void CConfig::set_proto(const void* value, size_t size) {
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CConfig.proto)
}
inline std::string* CConfig::mutable_proto() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CConfig.proto)
  return proto_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CConfig::release_proto() {
  // @@protoc_insertion_point(field_release:cmsg.CConfig.proto)
  
  return proto_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CConfig::set_allocated_proto(std::string* proto) {
  if (proto != nullptr) {
    
  } else {
    
  }
  proto_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proto);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CConfig.proto)
}

// -------------------------------------------------------------------

// CDownloadconfigReq

// int32 servicePort = 1;
inline void CDownloadconfigReq::clear_serviceport() {
  serviceport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CDownloadconfigReq::serviceport() const {
  // @@protoc_insertion_point(field_get:cmsg.CDownloadconfigReq.servicePort)
  return serviceport_;
}
inline void CDownloadconfigReq::set_serviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  serviceport_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CDownloadconfigReq.servicePort)
}

// string serviceIp = 2;
inline void CDownloadconfigReq::clear_serviceip() {
  serviceip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CDownloadconfigReq::serviceip() const {
  // @@protoc_insertion_point(field_get:cmsg.CDownloadconfigReq.serviceIp)
  return serviceip_.GetNoArena();
}
inline void CDownloadconfigReq::set_serviceip(const std::string& value) {
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CDownloadconfigReq.serviceIp)
}
inline void CDownloadconfigReq::set_serviceip(std::string&& value) {
  
  serviceip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CDownloadconfigReq.serviceIp)
}
inline void CDownloadconfigReq::set_serviceip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CDownloadconfigReq.serviceIp)
}
inline void CDownloadconfigReq::set_serviceip(const char* value, size_t size) {
  
  serviceip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CDownloadconfigReq.serviceIp)
}
inline std::string* CDownloadconfigReq::mutable_serviceip() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CDownloadconfigReq.serviceIp)
  return serviceip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CDownloadconfigReq::release_serviceip() {
  // @@protoc_insertion_point(field_release:cmsg.CDownloadconfigReq.serviceIp)
  
  return serviceip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CDownloadconfigReq::set_allocated_serviceip(std::string* serviceip) {
  if (serviceip != nullptr) {
    
  } else {
    
  }
  serviceip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serviceip);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CDownloadconfigReq.serviceIp)
}

// -------------------------------------------------------------------

// CConfigList

// repeated .cmsg.CConfig config = 1;
inline int CConfigList::config_size() const {
  return config_.size();
}
inline void CConfigList::clear_config() {
  config_.Clear();
}
inline ::cmsg::CConfig* CConfigList::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:cmsg.CConfigList.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CConfig >*
CConfigList::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:cmsg.CConfigList.config)
  return &config_;
}
inline const ::cmsg::CConfig& CConfigList::config(int index) const {
  // @@protoc_insertion_point(field_get:cmsg.CConfigList.config)
  return config_.Get(index);
}
inline ::cmsg::CConfig* CConfigList::add_config() {
  // @@protoc_insertion_point(field_add:cmsg.CConfigList.config)
  return config_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cmsg::CConfig >&
CConfigList::config() const {
  // @@protoc_insertion_point(field_list:cmsg.CConfigList.config)
  return config_;
}

// -------------------------------------------------------------------

// CDownloadAllConfigReq

// int32 page = 1;
inline void CDownloadAllConfigReq::clear_page() {
  page_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CDownloadAllConfigReq::page() const {
  // @@protoc_insertion_point(field_get:cmsg.CDownloadAllConfigReq.page)
  return page_;
}
inline void CDownloadAllConfigReq::set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CDownloadAllConfigReq.page)
}

// int32 pageCount = 2;
inline void CDownloadAllConfigReq::clear_pagecount() {
  pagecount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CDownloadAllConfigReq::pagecount() const {
  // @@protoc_insertion_point(field_get:cmsg.CDownloadAllConfigReq.pageCount)
  return pagecount_;
}
inline void CDownloadAllConfigReq::set_pagecount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pagecount_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CDownloadAllConfigReq.pageCount)
}

// -------------------------------------------------------------------

// CGatewayConfig

// bool isSSL = 1;
inline void CGatewayConfig::clear_isssl() {
  isssl_ = false;
}
inline bool CGatewayConfig::isssl() const {
  // @@protoc_insertion_point(field_get:cmsg.CGatewayConfig.isSSL)
  return isssl_;
}
inline void CGatewayConfig::set_isssl(bool value) {
  
  isssl_ = value;
  // @@protoc_insertion_point(field_set:cmsg.CGatewayConfig.isSSL)
}

// string crtPath = 2;
inline void CGatewayConfig::clear_crtpath() {
  crtpath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CGatewayConfig::crtpath() const {
  // @@protoc_insertion_point(field_get:cmsg.CGatewayConfig.crtPath)
  return crtpath_.GetNoArena();
}
inline void CGatewayConfig::set_crtpath(const std::string& value) {
  
  crtpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CGatewayConfig.crtPath)
}
inline void CGatewayConfig::set_crtpath(std::string&& value) {
  
  crtpath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CGatewayConfig.crtPath)
}
inline void CGatewayConfig::set_crtpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  crtpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CGatewayConfig.crtPath)
}
inline void CGatewayConfig::set_crtpath(const char* value, size_t size) {
  
  crtpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CGatewayConfig.crtPath)
}
inline std::string* CGatewayConfig::mutable_crtpath() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CGatewayConfig.crtPath)
  return crtpath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CGatewayConfig::release_crtpath() {
  // @@protoc_insertion_point(field_release:cmsg.CGatewayConfig.crtPath)
  
  return crtpath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CGatewayConfig::set_allocated_crtpath(std::string* crtpath) {
  if (crtpath != nullptr) {
    
  } else {
    
  }
  crtpath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crtpath);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CGatewayConfig.crtPath)
}

// string keyPath = 3;
inline void CGatewayConfig::clear_keypath() {
  keypath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CGatewayConfig::keypath() const {
  // @@protoc_insertion_point(field_get:cmsg.CGatewayConfig.keyPath)
  return keypath_.GetNoArena();
}
inline void CGatewayConfig::set_keypath(const std::string& value) {
  
  keypath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CGatewayConfig.keyPath)
}
inline void CGatewayConfig::set_keypath(std::string&& value) {
  
  keypath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CGatewayConfig.keyPath)
}
inline void CGatewayConfig::set_keypath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  keypath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CGatewayConfig.keyPath)
}
inline void CGatewayConfig::set_keypath(const char* value, size_t size) {
  
  keypath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CGatewayConfig.keyPath)
}
inline std::string* CGatewayConfig::mutable_keypath() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CGatewayConfig.keyPath)
  return keypath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CGatewayConfig::release_keypath() {
  // @@protoc_insertion_point(field_release:cmsg.CGatewayConfig.keyPath)
  
  return keypath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CGatewayConfig::set_allocated_keypath(std::string* keypath) {
  if (keypath != nullptr) {
    
  } else {
    
  }
  keypath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keypath);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CGatewayConfig.keyPath)
}

// string caPath = 4;
inline void CGatewayConfig::clear_capath() {
  capath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CGatewayConfig::capath() const {
  // @@protoc_insertion_point(field_get:cmsg.CGatewayConfig.caPath)
  return capath_.GetNoArena();
}
inline void CGatewayConfig::set_capath(const std::string& value) {
  
  capath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CGatewayConfig.caPath)
}
inline void CGatewayConfig::set_capath(std::string&& value) {
  
  capath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CGatewayConfig.caPath)
}
inline void CGatewayConfig::set_capath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  capath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CGatewayConfig.caPath)
}
inline void CGatewayConfig::set_capath(const char* value, size_t size) {
  
  capath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CGatewayConfig.caPath)
}
inline std::string* CGatewayConfig::mutable_capath() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CGatewayConfig.caPath)
  return capath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CGatewayConfig::release_capath() {
  // @@protoc_insertion_point(field_release:cmsg.CGatewayConfig.caPath)
  
  return capath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CGatewayConfig::set_allocated_capath(std::string* capath) {
  if (capath != nullptr) {
    
  } else {
    
  }
  capath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), capath);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CGatewayConfig.caPath)
}

// -------------------------------------------------------------------

// CAddUserReq

// string username = 1;
inline void CAddUserReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddUserReq::username() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddUserReq.username)
  return username_.GetNoArena();
}
inline void CAddUserReq::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddUserReq.username)
}
inline void CAddUserReq::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddUserReq.username)
}
inline void CAddUserReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddUserReq.username)
}
inline void CAddUserReq::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddUserReq.username)
}
inline std::string* CAddUserReq::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddUserReq.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddUserReq::release_username() {
  // @@protoc_insertion_point(field_release:cmsg.CAddUserReq.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddUserReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddUserReq.username)
}

// string password = 2;
inline void CAddUserReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddUserReq::password() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddUserReq.password)
  return password_.GetNoArena();
}
inline void CAddUserReq::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddUserReq.password)
}
inline void CAddUserReq::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddUserReq.password)
}
inline void CAddUserReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddUserReq.password)
}
inline void CAddUserReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddUserReq.password)
}
inline std::string* CAddUserReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddUserReq.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddUserReq::release_password() {
  // @@protoc_insertion_point(field_release:cmsg.CAddUserReq.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddUserReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddUserReq.password)
}

// string rolename = 3;
inline void CAddUserReq::clear_rolename() {
  rolename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CAddUserReq::rolename() const {
  // @@protoc_insertion_point(field_get:cmsg.CAddUserReq.rolename)
  return rolename_.GetNoArena();
}
inline void CAddUserReq::set_rolename(const std::string& value) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CAddUserReq.rolename)
}
inline void CAddUserReq::set_rolename(std::string&& value) {
  
  rolename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CAddUserReq.rolename)
}
inline void CAddUserReq::set_rolename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CAddUserReq.rolename)
}
inline void CAddUserReq::set_rolename(const char* value, size_t size) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CAddUserReq.rolename)
}
inline std::string* CAddUserReq::mutable_rolename() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CAddUserReq.rolename)
  return rolename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CAddUserReq::release_rolename() {
  // @@protoc_insertion_point(field_release:cmsg.CAddUserReq.rolename)
  
  return rolename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CAddUserReq::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CAddUserReq.rolename)
}

// -------------------------------------------------------------------

// CDirConfig

// string root = 1;
inline void CDirConfig::clear_root() {
  root_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CDirConfig::root() const {
  // @@protoc_insertion_point(field_get:cmsg.CDirConfig.root)
  return root_.GetNoArena();
}
inline void CDirConfig::set_root(const std::string& value) {
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmsg.CDirConfig.root)
}
inline void CDirConfig::set_root(std::string&& value) {
  
  root_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmsg.CDirConfig.root)
}
inline void CDirConfig::set_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmsg.CDirConfig.root)
}
inline void CDirConfig::set_root(const char* value, size_t size) {
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmsg.CDirConfig.root)
}
inline std::string* CDirConfig::mutable_root() {
  
  // @@protoc_insertion_point(field_mutable:cmsg.CDirConfig.root)
  return root_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CDirConfig::release_root() {
  // @@protoc_insertion_point(field_release:cmsg.CDirConfig.root)
  
  return root_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CDirConfig::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root);
  // @@protoc_insertion_point(field_set_allocated:cmsg.CDirConfig.root)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cmsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cmsg::CLoginRes_CLoginResType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmsg::CLoginRes_CLoginResType>() {
  return ::cmsg::CLoginRes_CLoginResType_descriptor();
}
template <> struct is_proto_enum< ::cmsg::CDirRes_CDirType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmsg::CDirRes_CDirType>() {
  return ::cmsg::CDirRes_CDirType_descriptor();
}
template <> struct is_proto_enum< ::cmsg::CMessageRes_CReturn> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmsg::CMessageRes_CReturn>() {
  return ::cmsg::CMessageRes_CReturn_descriptor();
}
template <> struct is_proto_enum< ::cmsg::CLogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmsg::CLogLevel>() {
  return ::cmsg::CLogLevel_descriptor();
}
template <> struct is_proto_enum< ::cmsg::CServiceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmsg::CServiceType>() {
  return ::cmsg::CServiceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cmsgcom_2eproto
